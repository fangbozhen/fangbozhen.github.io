<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fbz</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fangbozhen.github.io/"/>
  <updated>2019-11-10T13:09:31.135Z</updated>
  <id>https://fangbozhen.github.io/</id>
  
  <author>
    <name>fbz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BSGS及其扩展算法</title>
    <link href="https://fangbozhen.github.io/2019/11/10/BSGS%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95/"/>
    <id>https://fangbozhen.github.io/2019/11/10/BSGS及其扩展算法/</id>
    <published>2019-11-10T12:53:42.629Z</published>
    <updated>2019-11-10T13:09:31.135Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>Baby Step Giant Step，优美的暴力<br><a id="more"></a></p><h1 id="一、BSGS算法"><a href="#一、BSGS算法" class="headerlink" title="一、BSGS算法"></a>一、BSGS算法</h1><p>&emsp;&emsp;$BSGS$主要有两种写法，本质上都属于有没得暴力，不过基础的$BSGS$算法只能解决模数为质数的情况。</p><p>&emsp;&emsp;写法$1$：</p><p>&emsp;&emsp;为了求$a^x\equiv b\pmod c$我们考虑令$m=\lceil \sqrt{c}\rceil$,那么$x=i\times m+j$，其中$0\le j &lt;m$,我们只要预先处理处每个$a^j$模$c$的值存入$hash$表，暴力枚举$i$，对于每个$(a^m)^i\times (a^j)\equiv b\pmod c$，用扩展欧几里得求出$a^j$，再在$hash$表中查找即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct hash</span><br><span class="line">&#123;</span><br><span class="line">static const ll MOD=7679977;</span><br><span class="line">ll head[MOD+10],val[MOD+10],st[1&lt;&lt;16],top;</span><br><span class="line">hash()&#123;top=0;memset(head,0xff,sizeof(head));&#125;</span><br><span class="line">ll locate(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ll now=x%MOD;</span><br><span class="line">while(head[now]!=-1&amp;&amp;head[now]!=x)now++;</span><br><span class="line">return now;</span><br><span class="line">&#125;</span><br><span class="line">void insert(ll x,ll v)</span><br><span class="line">&#123;</span><br><span class="line">ll pos=locate(x);</span><br><span class="line">if(head[pos]==-1)head[pos]=x,val[pos]=v,st[++top]=pos;</span><br><span class="line">&#125;</span><br><span class="line">ll find(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ll pos=locate(x);</span><br><span class="line">return head[pos]==x?val[pos]:-1;</span><br><span class="line">&#125;</span><br><span class="line">void clear()&#123;while(top)head[st[top--]]=-1;&#125;</span><br><span class="line">&#125;hash;</span><br><span class="line"></span><br><span class="line">void exgcd(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">if(!b)g=a,x=1,y=0;</span><br><span class="line">else exgcd(b,a%b,g,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll BSGS(ll a,ll b,ll P)</span><br><span class="line">&#123;</span><br><span class="line">ll ed=ceil(sqrt(P));</span><br><span class="line">ll base=1;</span><br><span class="line">hash.clear();</span><br><span class="line">for(ll i=0;i&lt;ed;i++)</span><br><span class="line">&#123;</span><br><span class="line">hash.insert(base,i);</span><br><span class="line">base=base*a%P;</span><br><span class="line">&#125;</span><br><span class="line">ll s=1;</span><br><span class="line">for(ll i=0;i&lt;ed;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll g,x,y;</span><br><span class="line">exgcd(s,P,g,x,y);</span><br><span class="line">if(b%g)continue ;</span><br><span class="line">x=(x*(b/g)%(P/g)+(P/g))%(P/g);</span><br><span class="line">ll pos=hash.find(x);</span><br><span class="line">if(pos!=-1)return i*ed+pos;</span><br><span class="line">s=s*base%P;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll a,b,c;</span><br><span class="line">while(~scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c))</span><br><span class="line">printf(&quot;%lld\n&quot;,BSGS(a,b,c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;写法$2$：</p><p>&emsp;&emsp;我们还是令$m=\lceil \sqrt{c}\rceil$,对于$a^{i\times m+j}\equiv b\pmod c$,我们转化为$a^j\equiv a^{-i\times m}b\pmod c$同样的，我们暴力枚举$i$，看是否有对应的$a^j$在$hash$表中即可。</p><p>&emsp;&emsp;写法类似，代码就不贴了</p><h1 id="二、扩展BSGS算法"><a href="#二、扩展BSGS算法" class="headerlink" title="二、扩展BSGS算法"></a>二、扩展BSGS算法</h1><p>&emsp;&emsp;扩展$BSGS$算法可以实现模数不是质数的情况。</p><p>&emsp;&emsp;我们考虑对于$a^x\equiv b\pmod c$，令$g=gcd(a,c)$，如果$g\nmid b$，原方程必定无解，因为对于方程$a^{ans}\times x+c\times y=b$,由扩展欧几里得知必定无解，所以$A\times g\equiv B\times g \pmod {C\times g}$等价于$A\equiv B\pmod C$，所以我们可以不断进行分解，直到$gcd(a,c)=1$。</p><p>&emsp;&emsp;我们记进行的操作次数为$cnt$，令$s=\prod \frac{a}{gcd(a,c)}$，那么我们求得就可以转化为$s*a^{x-cnt}\equiv b\pmod c$，这里显然要使$x\ge cnt$，但显然可能存在$x&lt;cnt$的解，所以我们要先做一次枚举。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">struct hash</span><br><span class="line">&#123;</span><br><span class="line">static const ll MOD=7679977;</span><br><span class="line">ll head[MOD+10],val[MOD+10],st[1&lt;&lt;16],top;</span><br><span class="line">hash()&#123;top=0;memset(head,0xff,sizeof(head));&#125;</span><br><span class="line">ll locate(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ll now=x%MOD;</span><br><span class="line">while(head[now]!=-1&amp;&amp;head[now]!=x)now++;</span><br><span class="line">return now;</span><br><span class="line">&#125;</span><br><span class="line">void insert(ll x,ll v)</span><br><span class="line">&#123;</span><br><span class="line">ll pos=locate(x);</span><br><span class="line">if(head[pos]==-1)head[pos]=x,val[pos]=v,st[++top]=pos;</span><br><span class="line">&#125;</span><br><span class="line">ll find(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ll pos=locate(x);</span><br><span class="line">return head[pos]==x?val[pos]:-1;</span><br><span class="line">&#125;</span><br><span class="line">void clear()&#123;while(top)head[st[top--]]=-1;&#125;</span><br><span class="line">&#125;Hash;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)&#123;return !b?a:gcd(b,a%b);&#125;</span><br><span class="line">void exgcd(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">if(!b)g=a,x=1,y=0;</span><br><span class="line">else exgcd(b,a%b,g,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ExBSGS(ll a,ll b,ll P)</span><br><span class="line">&#123;</span><br><span class="line">ll tmp=1,s=1,cnt=0;</span><br><span class="line">for(ll i=0;i&lt;64;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(tmp==b)return i;</span><br><span class="line">tmp=tmp*a%P;</span><br><span class="line">&#125;</span><br><span class="line">for(ll g;(g=gcd(a,P))!=1;cnt++)</span><br><span class="line">&#123;</span><br><span class="line">if(b%g)return -1;</span><br><span class="line">b/=g;P/=g;</span><br><span class="line">s=s*a/g%P;</span><br><span class="line">&#125;</span><br><span class="line">ll ed=ceil(sqrt(P));</span><br><span class="line">ll base=1;</span><br><span class="line">Hash.clear();</span><br><span class="line">for(ll i=0;i&lt;ed;i++)</span><br><span class="line">&#123;</span><br><span class="line">Hash.insert(base,i);</span><br><span class="line">base=base*a%P;</span><br><span class="line">&#125;</span><br><span class="line">for(ll i=0;i&lt;ed;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll g,x,y;</span><br><span class="line">exgcd(s,P,g,x,y);</span><br><span class="line">if(b%g)continue ;</span><br><span class="line">x=(x*(b/g)%(P/g)+(P/g))%(P/g);</span><br><span class="line">ll pos=Hash.find(x);</span><br><span class="line">if(pos!=-1)return i*ed+pos+cnt;</span><br><span class="line">s=s*base%P;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll a,b,c;</span><br><span class="line">while(~scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;c,&amp;b)&amp;&amp;(a|b|c))</span><br><span class="line">&#123;</span><br><span class="line">ll ans=ExBSGS(a,b,c); </span><br><span class="line">if(ans!=-1)printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">else puts(&quot;No Solution&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;Baby Step Giant Step，优美的暴力&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>素数</title>
    <link href="https://fangbozhen.github.io/2019/11/08/%E7%B4%A0%E6%95%B0/"/>
    <id>https://fangbozhen.github.io/2019/11/08/素数/</id>
    <published>2019-11-08T09:36:26.147Z</published>
    <updated>2019-11-10T13:08:17.682Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>素数，并不简单朴素。<br><a id="more"></a></p><h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>&emsp;&emsp;素数又称质数，是指一个大于$1$的正整数，如果除了$1$和它本身外，没有其他任何约数。偶素数只有一个为$2$。</p><p>&emsp;&emsp;对于正实数$x$，定义$\pi(x)$为不大于$x$的素数个数，那么$\pi(x)\approx\frac{x}{ln(x)}$</p><h1 id="二、素数的判定"><a href="#二、素数的判定" class="headerlink" title="二、素数的判定"></a>二、素数的判定</h1><p>&emsp;&emsp;对于单个数或数据范围比较小时，我们采用枚举法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool is_prime(int x)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=2;i&lt;=sqrt(x);i++)</span><br><span class="line">if(!(x%i))return 0;</span><br><span class="line">return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;对于比较大的数据范围，并且要求出范围内的所有质数，我们卡可以采用筛选法</p><p>&emsp;&emsp;1、$Eratosthenes$筛选法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void get_prime(int N)</span><br><span class="line">&#123;</span><br><span class="line">memset(v,0,sizeof(v));</span><br><span class="line">for(int i=2;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(v[i])continue ;</span><br><span class="line">prime[++cnt]=i;</span><br><span class="line">for(int j=i;j&lt;=N/i;j++)v[i*j]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;不过我们发现这个筛法的效率并不高，因为它会重复筛选同一个质数。因此，就有了第二种筛法——快速线性筛法，它的复杂度几乎是线性的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void get_prime(int N)</span><br><span class="line">&#123;</span><br><span class="line">memset(v,0,sizeof(v));</span><br><span class="line">for(int i=2;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!v[i])prime[++cnt]=i;</span><br><span class="line">for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=N;j++)</span><br><span class="line">&#123;</span><br><span class="line">v[i*prime[j]=1;</span><br><span class="line">if(!(i%prime[j]))break ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;我们考虑每一个数至多被筛选一次，对于当前的$i$，如果$i$是素数，显然它和之前的素数不重复，必定筛选出的是新的数；如果$i$是合数，由于循环只会循环到比$i$的最小的质因子还要小的数，所以新加入的质数必定小于$i$的任何质因子，感性理解一下由于质因子序列不减所以不会重复。</p><h1 id="三、素数相关的定理"><a href="#三、素数相关的定理" class="headerlink" title="三、素数相关的定理"></a>三、素数相关的定理</h1><p>&emsp;&emsp;1、唯一分解定理<br>定理：对于一个整数$a$满足$a\ge2$，那么$a$一定可以分解为若干素数的乘积且在不计顺序时唯一。</p><script type="math/tex; mode=display">a=p_1^{r_1}\times p_2^{r_2}\times p_3^{r_3}\times ···\times p_n^{r_n}(p_i为素数)</script><p>&emsp;&emsp;2、威尔逊定理<br>定理：若$p$为素数，那么$(p-1)!\equiv-1\pmod p$成立  </p><p>&emsp;&emsp;逆定理：若$(p-1)!\equiv-1\pmod p$成立，那么$p$为素数</p><p>&emsp;&emsp;证明：1、必要性</p><p>&emsp;&emsp;&emsp;&emsp;若$p$不是质数，我们假设$a$为$p$的质因子</p><p>&emsp;&emsp;&emsp;&emsp;那么显然$a\mid(p-1)!$,并且$a\nmid (p-1)!+1$</p><p>&emsp;&emsp;&emsp;&emsp;而$p\mid (p-1)!+1$可得$a\mid (p-1)!+1$前后矛盾</p><p>&emsp;&emsp;&emsp;2、充分性</p><p>&emsp;&emsp;&emsp;&emsp;对于$p=2$和$p=3$时，显然定理成立。</p><p>&emsp;&emsp;&emsp;&emsp;当$p \ge 5$时，令</p><script type="math/tex; mode=display">M=\{2，3，4，···，p-2\},N=\{1,2,···，p-1\}</script><p>&emsp;&emsp;&emsp;&emsp;对于$\forall a \in M$,令</p><script type="math/tex; mode=display">S=\{a,2a,···,(p-2)a\}</script><p>&emsp;&emsp;&emsp;&emsp;我们很容易知道对于$S$中的数模$p$都不为$0$，且$S$中元素模$p$两两值不相等</p><p>&emsp;&emsp;&emsp;&emsp;所以对于$\forall a\in M$,$\exists x \in N$使得$ax\equiv1\pmod p$</p><p>&emsp;&emsp;接下来考虑三种情况：</p><p>&emsp;&emsp;&emsp;&emsp;1、若$x=1$，那么$ax\%p=a\%p=a$，显然不成立</p><p>&emsp;&emsp;&emsp;&emsp;2、若$x=p-1$，那么$ax\%p=[(a-1)p+p-a]\%p=p-a$，显然也不成立</p><p>&emsp;&emsp;&emsp;&emsp;3、若$x=a$,那么$a^2\equiv1\pmod p$,即$(a-1)(a+1)\equiv0\pmod p$，那么$a=1$或$a=p-1$，显然不行。</p><p>&emsp;&emsp;所以对于$\forall a \in M,\exists x \in M$,且$x \neq a$，使得$ax\equiv1\pmod p$</p><p>&emsp;&emsp;因此$(p-2)!\equiv 1\pmod p$</p><p>&emsp;&emsp;而$p-1\equiv -1\pmod p$</p><p>&emsp;&emsp;所以$(p-1)!\equiv-1\pmod p$</p><p>&emsp;&emsp;3、费马定理</p><p>&emsp;&emsp;定理：若$p$为质数，$a$为正整数，且$a$和$p$互质，则：$a^{p-1}\equiv 1\pmod p$</p><p>&emsp;&emsp;这个的证明就比较简单了，从剩余系分析即可。而这其实是费马小定理的一种特例。</p><h1 id="Miller-Rabin素数测试"><a href="#Miller-Rabin素数测试" class="headerlink" title="Miller_Rabin素数测试"></a>Miller_Rabin素数测试</h1><p>&emsp;&emsp;用费马小定理可以有多种素数的测试方法，Miller-Rabin就是其中一种：</p><p>&emsp;&emsp;其算法步骤如下(设$N$为询问素数)：</p><p>&emsp;&emsp;&emsp;1、计算奇数$M$，使得$N=2^r\times M+1$</p><p>&emsp;&emsp;&emsp;2、选择随机数$A&lt;N$</p><p>&emsp;&emsp;&emsp;3、对于任意$i&lt;r$，若$A^{2^i\times M} mod N=N-1$，则$N$通过了随机数$A$的测试</p><p>&emsp;&emsp;&emsp;&emsp;&ensp;或者$A^Mmod N=1$,则$N$通过了随机数$A$的测试</p><p>&emsp;&emsp;经过$t$次，$N$不是素数的概率为$\frac{1}{4^t}$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h</span><br><span class="line">using namespace std;</span><br><span class="line">const int cnt=10;</span><br><span class="line"></span><br><span class="line">int qpow(int a,int b,int mod)</span><br><span class="line">&#123;</span><br><span class="line">int res=1;</span><br><span class="line">for(;b;b=1,a=a*a%mod)</span><br><span class="line">if(b&amp;1)res=res*a%mod;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Miller_Rabin(int n)</span><br><span class="line">&#123;</span><br><span class="line">if(n==2)return 1;</span><br><span class="line">for(int i=0;i&lt;cnt;i++)</span><br><span class="line">&#123;</span><br><span class="line">int a=rand()%(n-2)+2;</span><br><span class="line">if(qpow(a,n,n)!=a)return 0;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">srand(time(NULL));</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">if(Miller_Rabin(n))printf(&quot;Probably a prime\n&quot;);</span><br><span class="line">else printf(&quot;A composite\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这里还有第二种写法，不过需要一个推导，也是基于费马小定理<br>二次探测定理：</p><script type="math/tex; mode=display">对于质数p,方程x^2\equiv1\pmod p，有且只有两个根x\equiv \pm1\pmod p</script><p>&emsp;&emsp;所以我们考虑其逆定理，对于有非$x=1或p-1$的解的模数一定非负。</p><p>&emsp;&emsp;因此在用这种方法判断素数是，我们先求出$a^m$，再不断对这个数进行自乘，我们设$x=a^m\pmod n,y=a^2\pmod n$，如果$y=1且x!=1或n-1$显然$p$为合数，可以排除。最后乘完后判断$y$是否为$1$即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool Millar_Rabin(ll n)</span><br><span class="line">&#123;</span><br><span class="line">if(n==2)return 1;</span><br><span class="line">if(n&lt;2||!(n&amp;1))return 0;</span><br><span class="line"></span><br><span class="line">ll m=n-1,k=0;</span><br><span class="line">while((m&amp;1)==0)&#123;k++;m=1;&#125;</span><br><span class="line">for(ll i=0;i&lt;times;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll a=rand()%(n-1)+1;</span><br><span class="line">ll x=qpow(a,m,n),y=0;</span><br><span class="line">for(ll j=0;j&lt;k;j++)</span><br><span class="line">&#123;</span><br><span class="line">y=multi(x,x,n);</span><br><span class="line">if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1)return 0; </span><br><span class="line">x=y;</span><br><span class="line">&#125;</span><br><span class="line">if(y!=1)return 0;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><p>&emsp;&emsp;费马定理用来求解在素数模下，指数的同余性质，当模数为合数时，就需要用到欧拉定理。</p><p>&emsp;&emsp;欧拉函数$\varphi$：对于正整数$n$，欧拉函数是小于等于$n$中与$n$互质的数的个数。</p><p>引理1：</p><p>&emsp;&emsp;$①$如果$n$为某一个质数$p$，则：$\varphi(p)=p-1$</p><p>&emsp;&emsp;$②$如果$n$为某一个质数的幂次$p^a$,则：$\varphi(p^a)=(p-1)\times p^{a-1}$</p><p>&emsp;&emsp;$③$如果$n$为任意两个互质的数$a、b$的积，则：$\varphi(a\times b)=\varphi(a)\times \varphi(b)$</p><p>证明：</p><p>&emsp;&emsp;$①$显然；</p><p>&emsp;&emsp;$②$因为比$p^a$小的数有$p^a-1$个。其中，被$p$整除的有$p^{a-1}-1$,所以$\varphi(p^a)=p^a-1-(p^{a-1}-1)=(p-1)\times p^{a-1}$</p><p>&emsp;&emsp;$③$对于小于$a\times b$的数共有$a\times b-1$个，其中，只有既与$a$互质，又与$b$互质的数才会和$a\times b$互质，显然满足条件的个数为$\varphi(a)\times \varphi(b)$</p><p>引理2：</p><p>&emsp;&emsp;设$n=p_1^{r_1}\times p_2^{r_2}\times ···\times p_n^{r_n}$为正整数$n$的素数幂乘积表达式，则</p><script type="math/tex; mode=display">\varphi(n)=n\times (1-\frac{1}{p_1})\times (1-\frac{1}{p_2})\times ···\times (1-\frac{1}{p_n})</script><p>证明：<br>&emsp;&emsp;由于素数幂之间显然互质，由引理$1②③$可知：</p><p>&emsp;&emsp;$\varphi(n)=\varphi(p_1^{r_1})\times \varphi(p_2^{r_2})\times ···\times \varphi(p_n^{r_n})$</p><p>&emsp;&emsp;&emsp;&emsp;&ensp;$=p_1^{r_1}\times p_2^{r_2}\times ···\times p_n^{r_n}\times (1-\frac{1}{p_1})\times (1-\frac{1}{p_2})\times ···\times (1-\frac{1}{p_n})$</p><p>&emsp;&emsp;&emsp;&emsp;&ensp;$=n\times (1-\frac{1}{p_1})\times (1-\frac{1}{p_2})\times ···\times (1-\frac{1}{p_n})$</p><p>&emsp;&emsp;欧拉定理：若$a$与$m$互质，则$a^{\varphi(m)}\equiv1(mod m)$</p><h1 id="Pollard-Rho-算法求大数因子"><a href="#Pollard-Rho-算法求大数因子" class="headerlink" title="Pollard Rho 算法求大数因子"></a>Pollard Rho 算法求大数因子</h1><p>&emsp;&emsp;在讲$Pollard Rho$之前我们先提一下另一个大整数算法$Fermat$，其算法的实现是先将一个数$M$把而的因数都提取出来，使$M=N\times 2^k$，那么显然$N$是一个奇数，对于一个奇数，如果它是质数，我们就无须分解；如果是合数，我们必定可以转化为$N=c\times d$的形式，我们假设$a=\frac{c+d}{2}$,$b=\frac{c-d}{2}(cd)$,那么显然$N=a^2-b^2$。由于不等式$a^2+b^2\ge 2ab$,我们可知$a=\frac{c+d}{2}\ge \sqrt{c\times d}$，所以我们可以枚举大于$N$的完全平方数$a^2$,判断$a^2-N$是否为完全平方数即可。一组$a、b$就能就出一组$c、d$因子。</p><p>&emsp;&emsp;因此我们考虑一种更加有效的方法。$Pollard Rho$算法实质上是生成了两个随机数$a、b$，对于待分解的大整数$N$，我们不断计算$p=gcd(|a-b|,N)$，如果$p$不为$1$就又得到了一个因子，否则我们依赖前一个$a、b$计算，判断$a、b$是否形成循环，形成的话就退出。这样我们必定可以得到一个因子或得到$N$为质数，所以可以继续递归分解。</p><p>&emsp;&emsp;但有一点比较麻烦，一般情况下通常使用$b=(a^2+c)mod n$生成随机数据，但是这样判环会比较复杂，我们考虑一种更简便的方法，有一个$Floyd$发明的简便的算法，就是考虑如何使我们知道自己已经走完一圈了，我们只需要令$B$的速度是$A$的两倍，它们同时同向出发后，再次相遇时就走了一圈。</p><p>&emsp;&emsp;实际在实现时，我们发现如果$x_i=x_0$时退出，但这样太慢了，我们考虑直接对于一段$x_i$求$gcd$，我们直接把$s=s\times |y-x|$，对于这一段的$s$求$gcd$，而这个段的长度我们可以考虑倍增。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll times=10;</span><br><span class="line">const ll N=5500;</span><br><span class="line"></span><br><span class="line">ll read()</span><br><span class="line">&#123;</span><br><span class="line">ll res=0,w=1;</span><br><span class="line">char ch=getchar();</span><br><span class="line">while(!isdigit(ch))&#123;if(ch==&apos;-&apos;)w=-1;ch=getchar();&#125;</span><br><span class="line">while(isdigit(ch))res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch^48),ch=getchar();</span><br><span class="line">return res\times w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">return !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">ll qpow(ll a,ll b,ll mod)</span><br><span class="line">&#123;</span><br><span class="line">ll res=1;</span><br><span class="line">for(;b;b=1,a=a*a%mod)</span><br><span class="line">if(b&amp;1)res=res*a%mod;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll multi(ll a,ll b,ll mod)</span><br><span class="line">&#123;</span><br><span class="line">ll res=0;</span><br><span class="line">for(;b;b=1,a=(a&lt;&lt;1)%mod)</span><br><span class="line">if(b&amp;1)res=(res+a)%mod;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fac[N],r[N],cnt;</span><br><span class="line">bool Millar_Rabin(ll n)</span><br><span class="line">&#123;</span><br><span class="line">if(n==2)return 1;</span><br><span class="line">if(n&lt;2||!(n&amp;1))return 0;</span><br><span class="line"></span><br><span class="line">ll m=n-1,k=0;</span><br><span class="line">while((m&amp;1)==0)&#123;k++;m=1;&#125;</span><br><span class="line">for(ll i=0;i&lt;times;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll a=rand()%(n-1)+1;</span><br><span class="line">ll x=qpow(a,m,n),y=0;</span><br><span class="line">for(ll j=0;j&lt;k;j++)</span><br><span class="line">&#123;</span><br><span class="line">y=multi(x,x,n);</span><br><span class="line">if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1)return 0;</span><br><span class="line">x=y;</span><br><span class="line">&#125;</span><br><span class="line">if(y!=1)return 0;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll pollard_rho(ll n,ll c)</span><br><span class="line">&#123;</span><br><span class="line">ll i=1,k=2,s=1;</span><br><span class="line">ll x=rand()%(n-1)+1,y=x;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">x=(multi(x,x,n)+c)%n;</span><br><span class="line">s=multi(s,abs(y-x),n);</span><br><span class="line">if(y==x||!s)return n;</span><br><span class="line">if(i==k)</span><br><span class="line">&#123;</span><br><span class="line">ll g=gcd(s,n);</span><br><span class="line">if(g1&amp;&amp;g&lt;n)return g;</span><br><span class="line">y=x;k&lt;&lt;=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void find(ll n,ll c)</span><br><span class="line">&#123;</span><br><span class="line">if(n==1)return ;</span><br><span class="line">if(Millar_Rabin(n))&#123;fac[++cnt]=n;return ;&#125;</span><br><span class="line">ll p=n,k=c;</span><br><span class="line">while(p=n)p=pollard_rho(p,c--);</span><br><span class="line">find(p,k);</span><br><span class="line">find(n/p,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">while(~scanf(&quot;%lld&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">cnt=0;</span><br><span class="line">find(n,120);</span><br><span class="line">sort(fac+1,fac+cnt+1);</span><br><span class="line">r[1]=1;</span><br><span class="line">ll k=2;</span><br><span class="line">for(ll i=2;i&lt;=cnt;i++)</span><br><span class="line">if(fac[i]==fac[i-1])r[k-1]++;</span><br><span class="line">else r[k]=1,fac[k++]=fac[i];</span><br><span class="line">for(ll i=1;i&lt;k;i++)</span><br><span class="line">printf(&quot;%lld %lld\n&quot;,fac[i],r[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h1><p>&emsp;&emsp;这是一道$NOIP$的初赛题</p><p>&emsp;&emsp;阅读下列程序，写出程序结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll g(ll x)</span><br><span class="line">&#123;</span><br><span class="line">if(x&lt;=1)return x;</span><br><span class="line">return (2002*g(x-1)+2003*g(x-2))%2005;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">printf(&quot;%lld&quot;,g(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们分析一下题，实际就是给出递推式求解，我们必须推出通项公式。</p><p>&emsp;&emsp;因为:$g(0)=0,g(1)=1$</p><p>&emsp;&emsp;所以：$g(n)=[2002\times g(n-1)+2003\times g(n-2)]mod 2005$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$=[-3\times g(n-1)-2\times g(n-2)]mod 2005$</p><p>&emsp;&emsp;因此:$g(n)+g(n-1)=[-2\times (g(n-1)+g(n-2))]mod 2005$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$\equiv[(-2)^2\times (g(n-2)+g(n-3))]mod 2005$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$······$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$\equiv[(-2)^{n-1}\times (g(0)+g(1))]mod 2005$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$\equiv(-2)^{n-1}mod 2005$</p><p>&emsp;&emsp;又因为：</p><p>&emsp;&emsp;$g(n)+2\times g(n-1)=[-1\times (g(n-1)+2\times g(n-2))]mod 2005$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\equiv[(-1)^2\times (g(n-2)+2\times g(n-3))]mod 2005$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$······$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\equiv[(-1)^{n-1}\times (g(1)+2\times g(0))]mod 2005$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$(-1)^{n-1}mod 2005$</p><p>&emsp;&emsp;由上面两式可得：</p><script type="math/tex; mode=display">g(n)=[(-1)^n-(-2)^n]mod\ 2005</script><p>&emsp;&emsp;所以我们只需要类似快速幂的做法把指数分解做即可。</p><h1 id="例2-Visible-Lattice-Points"><a href="#例2-Visible-Lattice-Points" class="headerlink" title="例2 Visible Lattice Points"></a>例2 Visible Lattice Points</h1><p>&emsp;&emsp;从原点看第一象限的点，给出$n$的范围，求范围内能看到的点的个数</p><p>&emsp;&emsp;首先我们考虑看到的点一定是对称的，所以我们只要求出下三角或上三角的点数即可。</p><p>&emsp;&emsp;而我们考虑每次遍历$x=n$这条直线，会加入$\varphi(n)$个点，所以我们要求的就是$\sum_{i=1}^{n}\varphi(i)$</p><p>&emsp;&emsp;我们用欧拉函数的线性筛法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int phi[1005],prime[1005],cnt;</span><br><span class="line">bool v[1005];</span><br><span class="line">void pre(int N)</span><br><span class="line">&#123;</span><br><span class="line">phi[1]=1;</span><br><span class="line">for(int i=2;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!v[i])prime[++cnt]=i,phi[i]=i-1;</span><br><span class="line">for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;j++)</span><br><span class="line">&#123;</span><br><span class="line">v[i*prime[j]]=1;</span><br><span class="line">if(!(i%prime[j]))&#123;phi[i*prime[j]]=phi[i]*prime[j];break ;&#125;</span><br><span class="line">else phi[i*prime[j]]=phi[i]*(prime[j]-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">pre(1000);</span><br><span class="line">int t,cas=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">int n,ans=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">ans+=phi[i];</span><br><span class="line">printf(&quot;%d %d %d\n&quot;,++cas,n,ans*2+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;素数，并不简单朴素。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>逆元</title>
    <link href="https://fangbozhen.github.io/2019/11/08/%E9%80%86%E5%85%83/"/>
    <id>https://fangbozhen.github.io/2019/11/08/逆元/</id>
    <published>2019-11-08T09:36:26.147Z</published>
    <updated>2019-11-05T09:57:55.387Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>逆元，常见却在同余意义下不同寻常<br><a id="more"></a></p><h1 id="一、扩展欧几里得求逆元"><a href="#一、扩展欧几里得求逆元" class="headerlink" title="一、扩展欧几里得求逆元"></a>一、扩展欧几里得求逆元</h1><p>&emsp;&emsp;逆元的定义即是对于$a$，满足$ax≡1\pmod b$，就把$x$称作$a$在模$b$意义下的逆元，而扩展欧几里得可以就线性同余方程，这里显然适用。</p><h1 id="二、快速幂求逆元"><a href="#二、快速幂求逆元" class="headerlink" title="二、快速幂求逆元"></a>二、快速幂求逆元</h1><p>&emsp;&emsp;这里用到了费马小定理和欧拉定理。</p><p>&emsp;&emsp;费马小定理：对于素数$p$，有$a^{p-1}≡1\pmod m$</p><p>&emsp;&emsp;证明：首先根据同余的性质，我们可知若$a≡b\pmod m$，则$a\times c≡b\times c\pmod m$</p><p>&emsp;&emsp;&emsp;$∴$我们对于素数$p$的剩余系：$1,2,3,4…p-1$中的两个数$x$，$y$</p><p>&emsp;&emsp;&emsp;有$a\times x≡a\times y\pmod p$必定不成立，因为$p$为素数，所以可以约去$a$，得到$x=y$，这显然不成立</p><p>&emsp;&emsp;&emsp;$∴1,2,3,4…p-1$和$a,2a,3a,4a…(p-1)a$形成映射</p><p>&emsp;&emsp;&emsp;$∴(p-1)!≡(p-1)!a^{p-1}\pmod p$</p><p>&emsp;&emsp;&emsp;$∴$约去$(p-1)!$，得$a^{p-1}≡1\pmod p$</p><p>&emsp;&emsp;欧拉定理：对于任意互质正整数$a$，$n$，满足$a^{\varphi(n)}≡1\pmod n$</p><p>&emsp;&emsp;证明：与费马小定理类似，只是将剩余系改为小于$n$与$n$互质的数。</p><h1 id="三、线性递推（递归）"><a href="#三、线性递推（递归）" class="headerlink" title="三、线性递推（递归）"></a>三、线性递推（递归）</h1><p>&emsp;&emsp;对于$i$在模$p$意义下的逆元，我们可以用假设$p=k\times i+r(r&lt;i)$，因此显然：$k\times i+r≡0\pmod p$</p><p>&emsp;&emsp;而将等式两边同时乘上$i-1$和$r-1$得到：$k\times r-1+i-1≡0\pmod p$，移项后为$i-1≡-k\times r-1\pmod p$</p><p>&emsp;&emsp;因此$i-1≡-\lfloor\frac{p}{i}\rfloor \times (p\%i)-1\pmod p$</p><p>&emsp;&emsp;所以递推式为$inv[i]=-(p/i)* inv[p\%i]$</p><h1 id="四、阶乘逆元"><a href="#四、阶乘逆元" class="headerlink" title="四、阶乘逆元"></a>四、阶乘逆元</h1><p>&emsp;&emsp;显然对于阶乘$n!$的逆元为$\frac{1}{n!}$，所以阶乘逆元的递推公式即为$inv[i]=inv[i+1]*(i+1)$</p><h1 id="例1-Sumdiv"><a href="#例1-Sumdiv" class="headerlink" title="例1:Sumdiv"></a>例1:Sumdiv</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>&emsp;&emsp;求出$a^b$的所有约数的和模$9901$的值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;这道题实际上就是让我们求$(1+p_1+p_1^2+…+p_1^{r_1})(1+p_2+p_2^2+…+p_2^{r_1})…(1+p_n+p_n^2+…+p_n^{r_n})$</p><p>&emsp;&emsp;而对于每个素数的分解我们可以直接通过枚举因数得到，但我们还需要快速求每个因数的和。</p><p>&emsp;&emsp;方法一：对于每个求和，我们根据$r$的奇偶性分类，可以不断递归求解，递归式如下：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;$①$若$n$为奇数，$cal(p，n)=cal(p，n/2)×(1+p^{n/2}+1)$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;$②$若$n$为偶数，$cal(p，n)=cal(p，n/2-1)×(1+p^{n/2}+1)+p^{n/2}$</p><p>&emsp;&emsp;方法二：直接运用等比数列求和公式</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll N=1000000; </span><br><span class="line">const ll mod=9901;</span><br><span class="line"></span><br><span class="line">ll prime[N],r[N]; </span><br><span class="line">ll qpow(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">    ll res=1;</span><br><span class="line">    for(;b;b&gt;&gt;=1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">ll cal(ll p,ll n)</span><br><span class="line">&#123; </span><br><span class="line">    if(!n)return 1;</span><br><span class="line">    if(n&amp;1)</span><br><span class="line">        return cal(p,n&gt;&gt;1)*(1+qpow(p,(n&gt;&gt;1)+1))%mod;</span><br><span class="line">    else return (cal(p,(n&gt;&gt;1)-1)*(1+qpow(p,(n&gt;&gt;1)+1))%mod+qpow(p,n&gt;&gt;1))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a,b,cnt=0;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);</span><br><span class="line">    for(ll i=2;i&lt;=sqrt(a);i++)</span><br><span class="line">        if(!(a%i))</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">            while(!(a%i))r[cnt]++,a/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    if(a!=1)prime[++cnt]=a,r[cnt]=1;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    for(ll i=1;i&lt;=cnt;i++)</span><br><span class="line">        ans=ans*cal(prime[i],r[i]*b)%mod;</span><br><span class="line">    printf(&quot;%lld&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;逆元，常见却在同余意义下不同寻常&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>中国剩余定理</title>
    <link href="https://fangbozhen.github.io/2019/11/08/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <id>https://fangbozhen.github.io/2019/11/08/中国剩余定理/</id>
    <published>2019-11-08T09:36:26.131Z</published>
    <updated>2019-11-05T10:09:16.391Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？——孙子算经<br><a id="more"></a></p><h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>&emsp;&emsp;中国剩余定理可以用来求解一些线性同余方程组：</p><script type="math/tex; mode=display">\begin{cases}    x\equiv a_1\quad (mod \quad m_1) \\    x\equiv a_2\quad (mod \quad m_2) \\    ...\\    x\equiv a_n\quad (mod \quad m_n) \\\end{cases}</script><p>&emsp;&emsp;而前提条件是$m_1，m_2，…，m_n$之间两两互质。</p><h1 id="二、求解方法"><a href="#二、求解方法" class="headerlink" title="二、求解方法"></a>二、求解方法</h1><p>&emsp;&emsp;我们设$M=\prod_{i=1}^{n}{m_i}$。那么我们设$Mi=M/mi$，ti是线性同余方程$M_it_i≡1(mod \quad m_i)$的一个解</p><blockquote><p>定理：对于线性同余方程组，解为$x=\prod_{i=1}^{n}{a_iM_it_i}$，并且在模$M$意义下有唯一解。</p><p>证明：$∵$Mi是除mi以为所有模数的倍数<br>&emsp;&emsp;&emsp;$∴$对于$\forall k≠i$，都有$a_iM_it_i≡0(mod \quad m_k)$<br>&emsp;&emsp;又$∵a_iM_it_i≡a_i(mod \quad m_i)$<br>&emsp;&emsp;$∴$代入$x$，原方程组成立，并且在模M意义下唯一。</p></blockquote><p>&emsp;&emsp;因此我们只要用$exgcd$求出每个方程的解，在求和起来即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void exgcd(int a,int b,int &amp;g,int &amp;x,int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    if(!b)g=a,x=1,y=0;</span><br><span class="line">    else exgcd(b,a%b,g,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line">void IntChina(int a[],int m[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int M=1,res=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        M*=m[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int Mi=M/m[i],g,x,y;</span><br><span class="line">        exgcd(Mi,m[i],g,x,y);</span><br><span class="line">        res=(res+x*a[i]*Mi)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    return (res+M)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例1：Biorhythms"><a href="#例1：Biorhythms" class="headerlink" title="例1：Biorhythms"></a>例1：Biorhythms</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>&emsp;&emsp;人的体力、情感和智力周期为23、28和33天，给出三个日期表示体力、情感和智力为峰值的日期，再给出一个初始日期，求从这一天开始，再过多少天三个峰值同时出现。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;实际上就是让我们求解线性同余方程组的解:</p><script type="math/tex; mode=display">\begin{cases}    x \equiv a_1 \quad (mod \quad 23) \\    x \equiv a_2 \quad (mod \quad 28) \\    x \equiv a_3 \quad (mod \quad 33)\end{cases}</script><p>&emsp;&emsp;对于这个方程组，我们求出的解即为下一次三个都出现峰值得日期，减去初始日期即可。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll m[4]=&#123;0,23,28,33&#125;;</span><br><span class="line"></span><br><span class="line">void exgcd(ll a,ll b,ll &amp;g,ll &amp;x,ll &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    if(!b)g=a,x=1,y=0;</span><br><span class="line">    else exgcd(b,a%b,g,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a[4],d,cas=0;</span><br><span class="line">    while(~scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a[1],&amp;a[2],&amp;a[3],&amp;d))</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[1]==-1&amp;&amp;a[2]==-1&amp;&amp;a[3]==-1&amp;&amp;d==-1)break ;</span><br><span class="line">        ll M=21252,ans=0;</span><br><span class="line">        for(ll i=1;i&lt;=3;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll mi=M/m[i];</span><br><span class="line">            ll g,x,y;</span><br><span class="line">            exgcd(mi,m[i],g,x,y);</span><br><span class="line">            ans=(ans+mi*x*a[i])%M;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans-d+M)%M;</span><br><span class="line">        printf(&quot;Case %d: the next triple peak occurs in %d days.\n&quot;,++cas,ans==0?M:ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？——孙子算经&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Catalen数</title>
    <link href="https://fangbozhen.github.io/2019/11/08/Catalan%E6%95%B0/"/>
    <id>https://fangbozhen.github.io/2019/11/08/Catalan数/</id>
    <published>2019-11-08T09:36:26.131Z</published>
    <updated>2019-11-05T10:19:38.763Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>组合数学中的常用公式，计数类常用<br><a id="more"></a></p><h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>&emsp;&emsp;Catalan数是组合数学中在经常出现在计数问题中的数列，前几项为:</p><p>&emsp;&emsp;$1,2 , 5 ,14,42,132,429,1430,4862,16796,58786,208012,742900，……$</p><h1 id="二、求解公式"><a href="#二、求解公式" class="headerlink" title="二、求解公式"></a>二、求解公式</h1><p>&emsp;&emsp;Catalan数有$4$个常用的求解公式</p><p>&emsp;&emsp;$①$递归公式1</p><script type="math/tex; mode=display">f(n)=\sum_{i=1}^{n-1}f(i)\times f(n-i-1)</script><p>&emsp;&emsp;$②$递归公式2</p><script type="math/tex; mode=display">f(n)=\frac{f(n-1)\times (4\times n-2)}{n+1}</script><p>&emsp;&emsp;$③$组合公式1</p><script type="math/tex; mode=display">f(n)=\frac{C_{2n}^n}{n+1}</script><p>&emsp;&emsp;$④$组合公式2</p><script type="math/tex; mode=display">f(n)=C_{2n}^n-C_{2n}^{n-1}</script><h1 id="例1-二叉树计数"><a href="#例1-二叉树计数" class="headerlink" title="例1 二叉树计数"></a>例1 二叉树计数</h1><p>&emsp;&emsp;已知一个二叉树有n个节点，求该二叉树有多少种不同的形态。</p><p>&emsp;&emsp;定一个点为根,假设左子树有$i$个节点，右子树有$(n-i-1)$个节点，那么根据乘法原理把他乘起来即可。我们设f(n)为n个节点的不同的二叉树形态个数，那么答案为：</p><script type="math/tex; mode=display">f(n)=\sum_{i=1}^{n-1}f(i)\times f(n-i-1)</script><p>&emsp;&emsp;这显然就是Catalan数，用组合公式求解即可。</p><h1 id="例2-AB排列问题"><a href="#例2-AB排列问题" class="headerlink" title="例2 AB排列问题"></a>例2 AB排列问题</h1><p>&emsp;&emsp;有$n$个$A$和$n$个$B$排在一起，要求从$1$开始的任意位置$B$的个数不能超过$A$的个数，求方案数。</p><p>&emsp;&emsp;直接求解满足条件的比较复杂，我们考虑求不符合条件的情况</p><p>&emsp;&emsp;令$n$个$A$和$n$个$B$组成的序列$S$不满足条件，那么我们就必定可以找到一个位置$p$满足$S[1…2p+1]$中有$p+1$个$B$,$p$个$A$。我们将$S[2p+2…2n]$的所有$A$转$B$，$B$转$A$，可以得到一个由$n-1$个$n+1$个B，$n-1$个$A$组成的序列。</p><p>&emsp;&emsp;相应的，对于一个由$n-1$个$n+1$个B，$n-1$个$A$组成的序列，我们必定可以找到一个位置$p$满足$S[1…2p+1]$有$p+1$个$B$和$p$个$A$。把$S$剩下的转换之后，就得到一个由$n$个$A$和$n$个$B$组成的、存在一个前缀为$B$比$A$多的序列。</p><p>&emsp;&emsp;因此，这两个序列形成了一个双射，或者它们一一对应。</p><p>&emsp;&emsp;所以，根据组合数定义，符合条件的排列的个数为：</p><script type="math/tex; mode=display">C_{2n}^n-C_{2n}^{n-1}=\frac{C_{2n}^n}{n+1}=Cat_n</script><h1 id="例3-乘法加括号"><a href="#例3-乘法加括号" class="headerlink" title="例3 乘法加括号"></a>例3 乘法加括号</h1><p>&emsp;&emsp;对于连乘$a_1\times a_2\times a_3\times ···\times a_n$，可以通过加括号改变它的运算顺序，求有多少种运算顺序。</p><p>&emsp;&emsp;我们考虑把每一个数和符号都作为二叉树的节点，保证每个数都是二叉树的叶子节点，那么每次就是选择一个$\times $使得左边形成一棵二叉树，右边一棵。相当于把求的顺序分为前$pos$个和后$pos$个分开处理，答案也就是二叉树计数。</p><h1 id="例4-欧拉多边形的划分"><a href="#例4-欧拉多边形的划分" class="headerlink" title="例4 欧拉多边形的划分"></a>例4 欧拉多边形的划分</h1><p>&emsp;&emsp;给出凸$n$边形的边数，求有多少种分法可以把这个多边形分成互不重叠的$n-2$个三角形。</p><p>&emsp;&emsp;我们假定已经选择了一条边，那么一这条边必定会形成一个三角形的一边，而这个三角形也把这个多边形分成了两个多边形，我们设$H_n$为$n$边形的分割数，那么容易得到：</p><script type="math/tex; mode=display">H_n=H_{n-1}+H_3H_{n-2}+···+H_{n-2}H_3+H_{n-1}</script><p>&emsp;&emsp;我们再假设确定了一条对角线，把$n$边形分成两个多边形，边数之和为$n+2$，而从一个顶点出发的$n-3$条对角线所形成的分割数为:$H_3H_{n-1}+H_4H_{n-2}+···+H_4H_{n-2}+H_3H_{n-1}$,由于一条对角线有两个端点，重复计数两次，而每个分割实际重复统计了$n-3$次，所以从所有顶点出发的n边形划分数为：</p><script type="math/tex; mode=display">(n-3)H_n=\frac{n(H_3H_{n-1}+H_4H_{n-2}+···+H_4H_{n-2}+H_3H_{n-1})}{2}</script><p>&emsp;&emsp;联立两个式子得到：</p><script type="math/tex; mode=display">H_{n+1}=(\frac{4n-6}{n})H_n</script><p>&emsp;&emsp;而这也是$Catalan$数的公式之一，所以可知$H_n=Cat_{n-2}$</p>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;组合数学中的常用公式，计数类常用&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最大公约数</title>
    <link href="https://fangbozhen.github.io/2019/11/08/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    <id>https://fangbozhen.github.io/2019/11/08/最大公约数/</id>
    <published>2019-11-08T09:36:26.131Z</published>
    <updated>2019-11-10T10:11:34.768Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>最大公约数，gcd，exgcd<br><a id="more"></a></p><h1 id="一、辗转相除法"><a href="#一、辗转相除法" class="headerlink" title="一、辗转相除法"></a>一、辗转相除法</h1><p>&emsp;&emsp;$gcd(a，b)=gcd(b，a\%b)$</p><h1 id="二、二进制算法优化"><a href="#二、二进制算法优化" class="headerlink" title="二、二进制算法优化"></a>二、二进制算法优化</h1><p>&emsp;&emsp;若$x=y$，则$gcd(x,y)=x$，否则：</p><p>&emsp;&emsp;&emsp;$①$若$x$，$y$均为偶数，则$gcd(x,y)=2\times gcd(x/2，y/2)$；</p><p>&emsp;&emsp;&emsp;$②$若$x$为奇数，$y$为偶数，则$gcd(x,y)=2\times gcd(x，y/2)$；</p><p>&emsp;&emsp;&emsp;$③$若$x$为偶数，$y$为奇数，则$gcd(x,y)=2\times gcd(x/2，y)$；</p><p>&emsp;&emsp;&emsp;$④$若$x$，$y$均为奇数，则$gcd(x,y)=gcd(x-y，y)$；</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    if(x==0)return y;</span><br><span class="line">    if(y==0)return x;</span><br><span class="line">    for(i=0;!(x&amp;1);i++)x&gt;&gt;=1;</span><br><span class="line">    for(j=0;!(y&amp;1);j++)y&gt;&gt;=1;</span><br><span class="line">    if(j&lt;i)i=j;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x&lt;y)x^=y,y^=x,x^=y;</span><br><span class="line">        x-=y;</span><br><span class="line">        if(x==0)return y&lt;&lt;i;</span><br><span class="line">        while(!(x&amp;1))x&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、最小公倍数"><a href="#三、最小公倍数" class="headerlink" title="三、最小公倍数"></a>三、最小公倍数</h1><p>&emsp;&emsp;$LCM(a，b)×GCD(a，b)=a×b$</p><h1 id="四、扩展欧几里得算法"><a href="#四、扩展欧几里得算法" class="headerlink" title="四、扩展欧几里得算法"></a>四、扩展欧几里得算法</h1><p>&emsp;&emsp;首先我们有结论：$ax+by=c$的充分必要条件是$gcd(a，b)|c$</p><p>&emsp;&emsp;所以我们可以用扩展欧几里得定理来求解一组$ax+by=gcd(a,b)$的解</p><p>&emsp;&emsp;$∵gcd(a,b)=gcd(b，a\%b)$</p><p>&emsp;&emsp;$∴ax+by=gcd(a,b)=gcd(b，a\%b)=bx+(a\%b)y=bx+(a-a/b\times b)y=ay+((x-a/b\times y)b$</p><p>&emsp;&emsp;因此就可以得到$x$、$y$的转移等式，而$b=0$时显然$x=1$，$y=0$。</p><h1 id="五、求解线性同余方程"><a href="#五、求解线性同余方程" class="headerlink" title="五、求解线性同余方程"></a>五、求解线性同余方程</h1><p>&emsp;&emsp;对于不定方程$ax+by=c$，等价于$ax≡c\pmod b$，所以当我们用扩展欧几里得定理求出一组特解$x0$、$y0$后，通解为：</p><p>&emsp;&emsp;$x=x0+b\times t$，$y=y0-a\times t$，其中$t$为任意整数。</p><p>&emsp;&emsp;而对于最小正整数解，设t$=b/gcd(a,b)，x=(x\%t+t)\%t$。</p><h1 id="例1：欧几里得的游戏"><a href="#例1：欧几里得的游戏" class="headerlink" title="例1：欧几里得的游戏"></a>例1：欧几里得的游戏</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>&emsp;&emsp;有两个数$M$、$N$，每次可以将大的数减去小的数的正整数倍，先得到$0$的人获胜，给出$M$、$N$，求先手胜还是后手胜。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;首先我们考虑特例，这里假设所有$M&gt;N$：</p><p>&emsp;&emsp;$①$如果$M\%N=0$，那么显然先手胜。</p><p>&emsp;&emsp;$②$如果$M\%N≠0$，那么显然$(M，N)$这个状态可以转移到$(M-N\times K，N)$，极限状态为$(N，M\%N)$，这样就相当于又开了一局游戏。而对于每一种极限状态，我们都可知$N&lt;M&lt;N\times 2$，所以我们可以考虑取到$(M\%N+N，N)$，那么就保证每一次自己操作都是极限状态，而对于结束状态一定是极限状态，所以在两个人都按最优策略取时，胜方必定可以保证自己每次都取到极限状态，所以相当于做一次欧几里得算法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int m,n;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">        if(m&lt;n)m^=n,n^=m,m^=n;</span><br><span class="line">        bool f=1;</span><br><span class="line">        while(m/n==1&amp;&amp;m%n!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            int t=m%n;m=n;n=t;</span><br><span class="line">            f^=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(f)printf(&quot;Stan wins\n&quot;);</span><br><span class="line">        else printf(&quot;Ollie wins\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;最大公约数，gcd，exgcd&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>整除</title>
    <link href="https://fangbozhen.github.io/2019/11/08/%E6%95%B4%E9%99%A4/"/>
    <id>https://fangbozhen.github.io/2019/11/08/整除/</id>
    <published>2019-11-08T09:36:26.131Z</published>
    <updated>2019-11-05T12:05:48.020Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>简单的整除不简单，加油吧少年<br><a id="more"></a></p><h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>&emsp;&emsp;$a$是$b$的因数，或$b$是$a$的倍数，记作$a|b$ </p><p>&emsp;&emsp;整除的性质：</p><p>&emsp;&emsp;&emsp;$①$如果$a|b$，$b|c$，那么$a|c$；</p><p>&emsp;&emsp;&emsp;$②a|b$且$a|c$等价于对于任意整数$x、y$满足$a|(b\times x+c\times y)$;</p><p>&emsp;&emsp;&emsp;$③$设$m≠0$，那么$a|b$等价于$(m\times a)|(m\times b)$；</p><p>&emsp;&emsp;&emsp;$④$设整数$x、y$满足$a\times x+b\times y=1$，且$a|n$，$b|n$，那么$(a\times b)|n$；</p><p>&emsp;&emsp;&emsp;证明：$∵a|n$且$b|n$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$∴(a\times b)|(b\times n)$且$(a\times b)|(a\times n)$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$∴(a\times b)|(a\times n\times x+b\times n\times y)$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;又$∵a\times n\times x+b\times n\times y=(a\times x+b\times y)\times n=n$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$∴(a\times b)|n$。</p><p>&emsp;&emsp;&emsp;$⑤$若$b=q\times d+c$，那么$d|b$的充要条件是$d|c$。</p><h1 id="例1：church"><a href="#例1：church" class="headerlink" title="例1：church"></a>例1：church</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>&emsp;&emsp;给出$m\times n$个矩形，每个整数节点上有一个教堂，每个教堂与它八个方向的教堂有连边，求从某一点开始经过所有点的最短路径。</p><p>&emsp;&emsp;范围：$m、n≤10000$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;首先我们没有特别好的思路，就考虑爆搜打表，打出表后比较和$n、m$的关系，我们发现对于一般的$n、m$，满足如果$n\times m$为偶数，那么最少长度即为$m\times n$，否则为$m\times n+0.414$，由于$m==1||n==1$时不存在$1.414$的边，特判即可。</p><h1 id="例2：strongbox"><a href="#例2：strongbox" class="headerlink" title="例2：strongbox"></a>例2：strongbox</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>&emsp;&emsp;一个密码满足都是$[0，n-1]$的整数，并且如果$a$是密码，$b$是密码，那么(a+b)%n$都是密码，给出$n、k$和$k$个整数，其中$1\sim k-1$非密码，$k$为密码，求最多密码数。</p><p>&emsp;&emsp;范围：$1≤k≤250000，k≤n≤10^{14}$</p><p>&emsp;&emsp;结论$1$：如果$x$是密码，那么$x\times k\%n$也是密码。</p><p>&emsp;&emsp;证明：显然，它并没有要求$a、b$不相同，那么$x$的整数次倍一定是密码。</p><p>&emsp;&emsp;结论$2$：如果$x$是密码，那么$gcd(x，n)$也是密码。</p><p>&emsp;&emsp;&emsp;证明：我们考虑$x\times k\%n=gcd(x，n)$，我们可以转化为$x\times k-n\times c=gcd(x，n)$</p><p>&emsp;&emsp;&emsp;$∵$对于二元一次方程$ax+by=c$，有整数解当且仅当$c\%gcd(a，b)=0$</p><p>&emsp;&emsp;&emsp;$∴$上述方程对于$k$一定有正整数解</p><p>&emsp;&emsp;&emsp;$∴gcd(x，n)$也是密码。</p><p>&emsp;&emsp;结论3：如果$x、y$是密码，那么$gcd(x，y)$也是密码</p><p>&emsp;&emsp;&emsp;证明：由结论1知$(a\times x+b\times y)\%n$也是密码</p><p>&emsp;&emsp;&emsp;$∵a\times x+b\times y=gcd(x，y)$一定有解</p><p>&emsp;&emsp;&emsp;$∴a\times x+b\times y≡gcd(x，y)\pmod n$一定有解(相等即可)</p><p>&emsp;&emsp;&emsp;$∵a\times x+b\times y\%n$一定是密码</p><p>&emsp;&emsp;&emsp;$∴gcd(x，y)$一定是密码</p><p>&emsp;&emsp;接下来我们考虑如何利用这几个结论，考虑对于一个密码集合$S$，设$A$中所有数的$gcd$为$x$</p><p>&emsp;&emsp;那么我们可以证明不存在比$x$小的数存在于$S$中，否则$x$将不是所有数的$gcd$</p><p>&emsp;&emsp;所以$S$中的数即为$x、2x、3x、······$</p><p>&emsp;&emsp;因此我们要密码集合尽可能多，那么我们就是要$x$尽可能的小。</p><p>&emsp;&emsp;所以对于一个密码，我们可以先用$gcd(a[k]，n)$将$a[k]$缩小，可知$x$是$a[k]$的因数，但它不是其他任何非密码的因数，因此我们也可以$gcd(a[i]，a[k])$把$a[i]$缩小，因为不是$a[k]$可以直接排除，这样之后的$a[i]$也一定是$a[k]$的因数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)&#123;return !b?a:gcd(b,a%b);&#125;</span><br><span class="line">ll a[310000],fac[310000];</span><br><span class="line">bool f[310000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n,k,cnt=0;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(ll i=1;i&lt;=k;i++)</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    a[k]=gcd(a[k],n);</span><br><span class="line">    for(ll i=1;i&lt;k;i++)</span><br><span class="line">        a[i]=gcd(a[i],a[k]);</span><br><span class="line">    for(ll i=1;i*i&lt;=a[k];i++)</span><br><span class="line">        if(a[k]%i==0)</span><br><span class="line">        &#123;</span><br><span class="line">            fac[++cnt]=i;</span><br><span class="line">            if(i*i!=a[k])fac[++cnt]=a[k]/i;</span><br><span class="line">        &#125;</span><br><span class="line">    sort(fac+1,fac+cnt+1);</span><br><span class="line">    for(ll i=1;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll pos=lower_bound(fac+1,fac+cnt+1,a[i])-fac;</span><br><span class="line">        if(pos&lt;=cnt)f[pos]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(ll i=1;i&lt;=cnt;i++)</span><br><span class="line">        if(f[i])</span><br><span class="line">        for(ll j=1;j&lt;i;j++)</span><br><span class="line">            if(fac[i]%fac[j]==0)f[j]=1;</span><br><span class="line">    for(ll i=1;;i++)</span><br><span class="line">        if(!f[i])&#123;printf(&quot;%lld&quot;,n/fac[i]);break ;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;简单的整除不简单，加油吧少年&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>同余</title>
    <link href="https://fangbozhen.github.io/2019/11/08/%E5%90%8C%E4%BD%99/"/>
    <id>https://fangbozhen.github.io/2019/11/08/同余/</id>
    <published>2019-11-08T09:36:26.131Z</published>
    <updated>2019-11-05T08:34:49.576Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>同余是数论的基本概念之一<br><a id="more"></a></p><h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>&emsp;&emsp;定义：对于$a$、$b$两个整数，如果$a$和$b$的差能被$m$整除，那么$a$和$b$关于模$m$同余，记作$a≡b\pmod m$</p><h1 id="二、性质"><a href="#二、性质" class="headerlink" title="二、性质"></a>二、性质</h1><p>&emsp;&emsp;对于整数$a$，$b$，$c$和自然数$m$、$n$，模$m$同余满足：</p><p>&emsp;&emsp;&emsp;1、自反性：$a≡a\pmod m$；</p><p>&emsp;&emsp;&emsp;2、对称性：若$a≡b\pmod m$，则$b≡a\pmod m$；</p><p>&emsp;&emsp;&emsp;3、传递性：若$a≡b\pmod m$，$b≡c\pmod m$，则$a≡c\pmod m$；</p><p>&emsp;&emsp;&emsp;4、同加性：若$a≡b\pmod m$，则$a+c≡b+c\pmod m$；</p><p>&emsp;&emsp;&emsp;5、同乘性：若$a≡b\pmod m$，则$a\times c≡b\times c\pmod m$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;若$a≡b\pmod m$，$c≡d\pmod m$，则$a\times c≡b\times d\pmod m$；</p><p>&emsp;&emsp;&emsp;6、同幂性：若$a≡b\pmod m$，则$an≡bn\pmod m$；</p><p>&emsp;&emsp;&emsp;7、推论1：$a\times b \pmod k=(a \pmod k)\times (b \pmod k)\pmod k$；</p><p>&emsp;&emsp;&emsp;8、推论2：若a mod p=x，a mod q=x，p、q互质，则a mod p\times q=x</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;证明：设$a div p=k1$，$b div q=k2$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;$∴a=p\times k1+x$，$b=k2\times q+x$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;$∴p\times k1=q\times k2$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;$∵p、q$互质</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;$∴\frac{k1}{q}$必定为整数，即$q|k1$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;$∴a=k\times p\times q+x$</p><h1 id="例1：Semi-prime-H-numbers"><a href="#例1：Semi-prime-H-numbers" class="headerlink" title="例1：Semi-prime H-numbers"></a>例1：Semi-prime H-numbers</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>&emsp;&emsp;形如$4n+1$的数称为$H$数，乘法在$H$数是封闭的。在这个集合中只能被$1$和本身整数整除的数称为$H-$素数，其余为$H-$合数。定义$H-$合成数为能且只能分解为$2$个$H-$素数的$H-$合数，求$0~h$中$H-$合成数的个数。　　</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;我们先考虑如何快速筛出$H-$素数，由于乘法在$H$数内封闭进行，并且有以下结论：</p><p>&emsp;&emsp;1、两个$H$数乘起来一定是$H$数</p><p>&emsp;&emsp;证明：我们设第一个$H$数等于$4a+1$，另一个为$4b+1$</p><p>&emsp;&emsp;&emsp;&emsp;$∴(4a+1)(4b+1)=16ab+4a+4b+1=4(4ab+a+b)+1$</p><p>&emsp;&emsp;&emsp;&emsp;$∴$乘积为$H$数</p><p>&emsp;&emsp;2、对于一个$H-$合数，必定可以分解为若干个$H-$素数的乘积。</p><p>&emsp;&emsp;3、对于一个$H-$素数，它的倍数一定是$H-$合数</p><p>&emsp;&emsp;有了以上结论，我们就可以利用类似线性筛的方法，把$H-$素数筛出来，不过还有一点需要解决，因为乘法封闭进行，因此$H-$素数的倍数也不是正常意义上的倍数，只是$(4n+1)$，其中$n$为正整数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e6+10;</span><br><span class="line"></span><br><span class="line">int prime[100005],sum[N];</span><br><span class="line">bool v[N],is[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=5;i&lt;N;i+=4)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!v[i])prime[++cnt]=i;</span><br><span class="line">        for(int j=i*5;j&lt;N;j+=i*4)</span><br><span class="line">            v[j]=1;</span><br><span class="line">    &#125;</span><br><span class="line">//    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)</span><br><span class="line">        for(int j=1;j&lt;=i&amp;&amp;prime[i]*prime[j]&lt;N;j++)</span><br><span class="line">            is[prime[i]*prime[j]]=1;</span><br><span class="line">    for(int i=1;i&lt;N;i++)</span><br><span class="line">        sum[i]=sum[i-1]+is[i];</span><br><span class="line">    int x;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;x)&amp;&amp;x)</span><br><span class="line">        printf(&quot;%d %d\n&quot;,x,sum[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;同余是数论的基本概念之一&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数</title>
    <link href="https://fangbozhen.github.io/2019/11/08/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>https://fangbozhen.github.io/2019/11/08/斐波那契数/</id>
    <published>2019-11-08T09:36:26.131Z</published>
    <updated>2019-11-05T10:15:15.689Z</updated>
    
    <content type="html"><![CDATA[<html><head><!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" id="MathJax-script" async  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html><p>斐波那契数列，是1，1，2，3，5，8，13，···,却不止于这个数列<br><a id="more"></a></p><h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>&emsp;&emsp;斐波那契数，又称黄金分割数列，是指数列:$0,1,1,2,3,5,8,……$。表示后一个数由前两个数的和组成，递归上定义为$f[0]=0,f[1]=1,f[i]=f[i-1]+f[i-2]$。</p><h1 id="二、通项公式"><a href="#二、通项公式" class="headerlink" title="二、通项公式"></a>二、通项公式</h1><p>&emsp;&emsp;接下来用推导斐波那契数的通项公式：<br>&emsp;&emsp;假设常数s、r满足：</p><p>&emsp;&emsp;&emsp;&emsp;$f[n]-r\times f[n-1]=s\times (f[n-1]-r\times f[n-2])$</p><p>&emsp;&emsp;再结合斐波那契数的定义，我们可以得到：</p><p>&emsp;&emsp;&emsp;&emsp;$r+s=1,rs=-1$</p><p>&emsp;&emsp;所以，对于$n≥3$时，有：</p><p>&emsp;&emsp;&emsp;&emsp;$f[n]-r\times f[n-1]=s\times (f[n-1]-r\times f[n-2])$</p><p>&emsp;&emsp;&emsp;&emsp;$f[n-1]-r\times f[n-2]=s\times (f[n-2]-r\times f[n-3])$</p><p>&emsp;&emsp;&emsp;&emsp;$……$</p><p>&emsp;&emsp;&emsp;&emsp;$f[3]-r\times f[2]=s\times (f[2]-r\times f[1])$</p><p>&emsp;&emsp;我们联立这n-2个式子，可以得到：</p><p>&emsp;&emsp;&emsp;&emsp;$f[n]-r\times f[n-1]=s^{n-2}\times (f[2]-r\times f[1])$</p><p>&emsp;&emsp;因为：</p><p>&emsp;&emsp;&emsp;&emsp;$s=1-r,f[1]=f[2]=1$</p><p>&emsp;&emsp;所以可以化简：</p><p>&emsp;&emsp;&emsp;&emsp;$f[n]=s^{n-1}+r\times f[n-1]$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$=s^{n-1}+r\times s^{n-2}+r^2\times f[n-2]$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$=s^{n-1}+r\times s^{n-2}+r^2\times s^{n-3}+r^3\times f[n-3]$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$……$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$=s^{n-1}+r\times s^{n-2}+r^2\times s^{n-3}+……+r^{n-1}$</p><p>&emsp;&emsp;这就是一个以$s^{n-1}$为首项，$r^{n-1}$为末项，$\frac{r}{s}$为公比的等比数列，直接运用等比数列求和公式：</p><script type="math/tex; mode=display">原式=\frac{s^{n-1}-r^{n-1}\times \frac{r}{s}}{1-\frac{r}{s}}</script><script type="math/tex; mode=display">=\frac{s^n-r^n}{s-r}</script><p>&emsp;&emsp;因为前文求出的两个关于$r、s$的式子其中一组解为：</p><script type="math/tex; mode=display">s=\frac{1+\sqrt{5}}{2},r=\frac{1-\sqrt{5}}{2}</script><p>&emsp;&emsp;所以通项公式为：</p><script type="math/tex; mode=display">f[n]=\frac{\sqrt{5}}{5}\times [(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n]</script><h1 id="例1-普通递归关系"><a href="#例1-普通递归关系" class="headerlink" title="例1 普通递归关系"></a>例1 普通递归关系</h1><p>&emsp;&emsp;给出以下定义在非负整数n下的递归关系：</p><script type="math/tex; mode=display">f[n]=\begin{cases}    f_0 \qquad \qquad \qquad \qquad \qquad \qquad n=0 \\    f_1 \qquad \qquad \qquad \qquad \qquad \qquad n=1 \\    a\times f[n-1]+b\times f[n-2] \qquad otherwise\end{cases}</script><p>&emsp;&emsp;其中$a、b$是满足以下两个条件的常数：</p><p>&emsp;&emsp;(一)$a^2+4b0$</p><p>&emsp;&emsp;(二)$|a-\sqrt{a^2+4b}|≤2$</p><p>&emsp;&emsp;给出$f_0,f_1,a,b,n$，求$f[n]$</p><p>&emsp;</p><p>&emsp;&emsp;我们考虑直接暴推公式，用类似斐波那契数的方法求得公式为：</p><script type="math/tex; mode=display">f[n]=\frac{s^n(f_1-mf_0)-r^n(f_1-kf_0)}{s-r}</script><p>&emsp;&emsp;其中：</p><script type="math/tex; mode=display">s、r=\frac{a±\sqrt{a^2+4b}}{2}</script><p>&emsp;&emsp;直接快速幂求解就行了。</p><p>&emsp;&emsp;然而推完式子后发现这实际上是复杂度理论上和矩阵快速幂一样的，而且矩阵快速幂好写很多，然后就不想写代码了。</p><h1 id="例2-数字迷阵"><a href="#例2-数字迷阵" class="headerlink" title="例2 数字迷阵"></a>例2 数字迷阵</h1><p>&emsp;&emsp;题面太长，懒得打了，自己去看吧。<a href="https://www.luogu.org/problem/P2544" target="_blank" rel="noopener">数字迷阵</a></p><p>&emsp;&emsp;我们考虑每一行都相当于是斐波那契数，只要求出前两项即可，所以我们考虑前两项的规律。</p><p>&emsp;&emsp;由于我们知道$A[i,2]=2A[i,1]-(i-1)$,只要考虑找出$A[i,1]$的规律即可。</p><p>&emsp;&emsp;对于$A[i,1]$，我们分析它的差值可以知道：</p><p>&emsp;&emsp;&emsp;&emsp;$1\sim2$行：$3$</p><p>&emsp;&emsp;&emsp;&emsp;$3\sim4$行：$2-3$</p><p>&emsp;&emsp;&emsp;&emsp;$5\sim7$行：$3-2-3$</p><p>&emsp;&emsp;&emsp;&emsp;$8\sim12$行：$2-3-3-2-3$</p><p>&emsp;&emsp;所以每次的差值就是由前两项的差值拼接起来，接下来就是求通项公式;</p><p>&emsp;&emsp;但我们发现直接求通项公式很复杂，代码也难以在合适的时间复杂度内模拟，我们考虑求出它的前两项（$0$列和$-1$列）：</p><div class="table-container"><table><thead><tr><th>列数</th><th style="text-align:center">-1</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:right">8</th></tr></thead><tbody><tr><td></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">5</td><td style="text-align:center">8</td><td style="text-align:center">13</td><td style="text-align:center">21</td><td style="text-align:center">34</td><td style="text-align:right">55  </td></tr><tr><td></td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">7</td><td style="text-align:center">11</td><td style="text-align:center">18</td><td style="text-align:center">29</td><td style="text-align:center">47</td><td style="text-align:center">76</td><td style="text-align:right">123 </td></tr><tr><td></td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">16</td><td style="text-align:center">26</td><td style="text-align:center">42</td><td style="text-align:center">68</td><td style="text-align:center">110</td><td style="text-align:right">178 </td></tr><tr><td></td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">9</td><td style="text-align:center">15</td><td style="text-align:center">24</td><td style="text-align:center">39</td><td style="text-align:center">63</td><td style="text-align:center">102</td><td style="text-align:center">165</td><td style="text-align:right">267 </td></tr><tr><td></td><td style="text-align:center">4</td><td style="text-align:center">8</td><td style="text-align:center">12</td><td style="text-align:center">20</td><td style="text-align:center">32</td><td style="text-align:center">52</td><td style="text-align:center">84</td><td style="text-align:center">136</td><td style="text-align:center">220</td><td style="text-align:right">356 </td></tr></tbody></table></div><p>&emsp;&emsp;所以我们可以发现第$-1$列的规律是自然数依次递增，而这个第$0$列，看着十分眼熟，实际上这与$Wythoff$博弈有关，我们知道$Wythoff$博弈的必胜态为：</p><script type="math/tex; mode=display">(1,2),(3,5),(4,7),(6,10),(8,13)……</script><p>&emsp;&emsp;而Wythoff博弈后手必胜态的通项为：</p><script type="math/tex; mode=display">(\lfloor{\phi}\rfloor,\lfloor\phi^2\rfloor),(\lfloor2\phi\rfloor,\lfloor2\phi^2\rfloor),(\lfloor3\phi\rfloor,\lfloor3\phi^2\rfloor),(\lfloor4\phi\rfloor,\lfloor4\phi^2\rfloor)……\\其中\phi=\frac{\sqrt{5}+1}{2}</script><p>定理：Wthyoff博弈的必胜态为序列$W$（即上述序列），通项公式为$(\lfloor n\phi\rfloor,\lfloor n\phi^2\rfloor)$</p><p>证明：我们先证明序列W满足这三个性质：</p><p>&emsp;&emsp;1、$W$无重复且不遗漏包含了所有整数</p><p>&emsp;&emsp;2、$W$中两数之差依次为1，2，3，4，……</p><p>&emsp;&emsp;3、$W$中的较小数依次递增</p><p>&emsp;&emsp;性质1：</p><blockquote><p>Beatty-Rayleigh 定理 </p><p>对于任意两个正无理数满足$\frac{1}{\alpha}+\frac{1}{\beta}=1$,那么数列$\lfloor\alpha\rfloor,\lfloor2\alpha\rfloor,\lfloor3\alpha\rfloor,……$和数列$\lfloor\beta\rfloor,\lfloor2\beta\rfloor,\lfloor3\beta\rfloor,……$既无重复有无遗漏的包含了所有的正整数</p></blockquote><p>&emsp;&emsp;而$\phi$和$\phi^2$恰好就是满足条件的两个正无理数(定理的具体证明就不写了)</p><p>&emsp;&emsp;性质$2$和$3$比较显然，我们可以直接由通项公式知道</p><p>&emsp;&emsp;由这三个性质我们可以知道三个关于W的条件</p><p>&emsp;&emsp;$1、W中的任意一个数对都无法一步变成终止状态(0,0)$</p><p>&emsp;&emsp;$2、W中的任意一个数对都无法通过一步变成W中的另一个数$</p><p>&emsp;&emsp;$3、W外的任何一个数对都可以一步变成(0,0)或W中的数对$</p><p>&emsp;&emsp;所以显然W是满足要求的数对</p><p>&emsp;&emsp;不过关于$Fibonacci$数列和$Wthyoff$还有很多更深的联系，就不再赘述了，大家想了解可以看<a href="http://www.matrix67.com/blog/archives/6784" target="_blank" rel="noopener">这位大佬的博客</a></p><p>&emsp;&emsp;所以我们从一道$Fibonacci$+矩阵快速幂题成功扯到了博弈，而事实关系远不止如此，题目中要我们求得表实际上就是$wthyoff$表，而这又和$Zeckendorf$表达有关，不得不感叹数学海洋的辽阔。</p><p>&emsp;&emsp;扯到这里，第$1$列的通项公式就出来了，由于第$-1$列的通项为$i-1$，第$0$列的通项为$\lfloor i\phi\rfloor$,所以第$1$列的通项就为$\lfloor i\phi+i-1 \rfloor$</p><p>&emsp;&emsp;已知前两项的斐波那契数做法就很多了，我们可以直接代入之前的公式，也可以用矩阵快速幂求解。</p><p>&emsp;&emsp;代码就不贴了，知道结论挺好写的。</p>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;
&lt;head&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; id=&quot;MathJax-script&quot; async
  src=&quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&quot;&gt;
&lt;/script&gt;&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;&lt;/body&gt;
&lt;/html&gt;

&lt;p&gt;斐波那契数列，是1，1，2，3，5，8，13，···,却不止于这个数列&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="https://fangbozhen.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论学习" scheme="https://fangbozhen.github.io/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
