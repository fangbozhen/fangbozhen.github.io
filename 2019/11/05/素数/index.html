<!DOCTYPE html><html lang="cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="素数"><meta name="keywords" content="数论学习"><meta name="author" content="fbz,undefined"><meta name="copyright" content="fbz"><title>素数【fbz】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、定义"><span class="toc-number">1.</span> <span class="toc-text">一、定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、素数的判定"><span class="toc-number">2.</span> <span class="toc-text">二、素数的判定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、素数相关的定理"><span class="toc-number">3.</span> <span class="toc-text">三、素数相关的定理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Miller-Rabin素数测试"><span class="toc-number">4.</span> <span class="toc-text">Miller_Rabin素数测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#欧拉定理"><span class="toc-number">5.</span> <span class="toc-text">欧拉定理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pollard-Rho-算法求大数因子"><span class="toc-number">6.</span> <span class="toc-text">Pollard Rho 算法求大数因子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#例1"><span class="toc-number">7.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#例2-Visible-Lattice-Points"><span class="toc-number">8.</span> <span class="toc-text">例2 Visible Lattice Points</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">fbz</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/fangbozhen" target="_blank">GitHub<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=3349001712@qq.com&quot;" target="_blank">E-Mail<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="tencent://message/?uin=3349001712&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">8</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">1</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">2</span></a></div><div class="friend-link"><a class="friend-link-text" href="https://oierlin.cf" target="_blank">Oblivion</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">fbz</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">素数</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-11-05 | 更新于 2019-11-05</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E8%AE%BA/">数论</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0/">数论学习</a></div></div></div><div class="main-content"><html>
<head>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><title>MathJax TeX Test Page</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>

<p>素数，并不简单朴素。<br><a id="more"></a></p>
<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>&emsp;&emsp;素数又称质数，是指一个大于$1$的正整数，如果除了$1$和它本身外，没有其他任何约数。偶素数只有一个为$2$。</p>
<p>&emsp;&emsp;对于正实数$x$，定义$\pi(x)$为不大于$x$的素数个数，那么$\pi(x)\approx\frac{x}{ln(x)}$</p>
<h1 id="二、素数的判定"><a href="#二、素数的判定" class="headerlink" title="二、素数的判定"></a>二、素数的判定</h1><p>&emsp;&emsp;对于单个数或数据范围比较小时，我们采用枚举法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool is_prime(int x)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=2;i&lt;=sqrt(x);i++)</span><br><span class="line">		if(!(x%i))return 0;</span><br><span class="line">	return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;对于比较大的数据范围，并且要求出范围内的所有质数，我们卡可以采用筛选法</p>
<p>&emsp;&emsp;1、$Eratosthenes$筛选法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void get_prime(int N)</span><br><span class="line">&#123;</span><br><span class="line">	memset(v,0,sizeof(v));</span><br><span class="line">	for(int i=2;i&lt;=N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(v[i])continue ;</span><br><span class="line">		prime[++cnt]=i;</span><br><span class="line">		for(int j=i;j&lt;=N/i;j++)v[i*j]=1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;不过我们发现这个筛法的效率并不高，因为它会重复筛选同一个质数。因此，就有了第二种筛法——快速线性筛法，它的复杂度几乎是线性的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void get_prime(int N)</span><br><span class="line">&#123;</span><br><span class="line">	memset(v,0,sizeof(v));</span><br><span class="line">	for(int i=2;i&lt;=N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!v[i])prime[++cnt]=i;</span><br><span class="line">		for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			v[i*prime[j]=1;</span><br><span class="line">			if(!(i%prime[j]))break ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;我们考虑每一个数至多被筛选一次，对于当前的$i$，如果$i$是素数，显然它和之前的素数不重复，必定筛选出的是新的数；如果$i$是合数，由于循环只会循环到比$i$的最小的质因子还要小的数，所以新加入的质数必定小于$i$的任何质因子，感性理解一下由于质因子序列不减所以不会重复。</p>
<h1 id="三、素数相关的定理"><a href="#三、素数相关的定理" class="headerlink" title="三、素数相关的定理"></a>三、素数相关的定理</h1><p>&emsp;&emsp;1、唯一分解定理<br>定理：对于一个整数$a$满足$a\ge2$，那么$a$一定可以分解为若干素数的乘积且在不计顺序时唯一。</p>
<script type="math/tex; mode=display">a=p_1^{r_1}\times p_2^{r_2}\times p_3^{r_3}\times ···\times p_n^{r_n}(p_i为素数)</script><p>&emsp;&emsp;2、威尔逊定理<br>定理：若$p$为素数，那么$(p-1)!\equiv-1\pmod p$成立  </p>
<p>&emsp;&emsp;逆定理：若$(p-1)!\equiv-1\pmod p$成立，那么$p$为素数</p>
<p>&emsp;&emsp;证明：1、必要性</p>
<p>&emsp;&emsp;&emsp;&emsp;若$p$不是质数，我们假设$a$为$p$的质因子</p>
<p>&emsp;&emsp;&emsp;&emsp;那么显然$a\mid(p-1)!$,并且$a\nmid (p-1)!+1$</p>
<p>&emsp;&emsp;&emsp;&emsp;而$p\mid (p-1)!+1$可得$a\mid (p-1)!+1$前后矛盾</p>
<p>&emsp;&emsp;&emsp;2、充分性</p>
<p>&emsp;&emsp;&emsp;&emsp;对于$p=2$和$p=3$时，显然定理成立。</p>
<p>&emsp;&emsp;&emsp;&emsp;当$p \ge 5$时，令</p>
<script type="math/tex; mode=display">
M=\{2，3，4，···，p-2\},N=\{1,2,···，p-1\}</script><p>&emsp;&emsp;&emsp;&emsp;对于$\forall a \in M$,令</p>
<script type="math/tex; mode=display">
S=\{a,2a,···,(p-2)a\}</script><p>&emsp;&emsp;&emsp;&emsp;我们很容易知道对于$S$中的数模$p$都不为$0$，且$S$中元素模$p$两两值不相等</p>
<p>&emsp;&emsp;&emsp;&emsp;所以对于$\forall a\in M$,$\exists x \in N$使得$ax\equiv1\pmod p$</p>
<p>&emsp;&emsp;接下来考虑三种情况：</p>
<p>&emsp;&emsp;&emsp;&emsp;1、若$x=1$，那么$ax\%p=a\%p=a$，显然不成立</p>
<p>&emsp;&emsp;&emsp;&emsp;2、若$x=p-1$，那么$ax\%p=[(a-1)p+p-a]\%p=p-a$，显然也不成立</p>
<p>&emsp;&emsp;&emsp;&emsp;3、若$x=a$,那么$a^2\equiv1\pmod p$,即$(a-1)(a+1)\equiv0\pmod p$，那么$a=1$或$a=p-1$，显然不行。</p>
<p>&emsp;&emsp;所以对于$\forall a \in M,\exists x \in M$,且$x \neq a$，使得$ax\equiv1\pmod p$</p>
<p>&emsp;&emsp;因此$(p-2)!\equiv 1\pmod p$</p>
<p>&emsp;&emsp;而$p-1\equiv -1\pmod p$</p>
<p>&emsp;&emsp;所以$(p-1)!\equiv-1\pmod p$</p>
<p>&emsp;&emsp;3、费马定理<br>定理：若$p$为质数，$a$为正整数，且$a$和$p$互质，则：$a^{p-1}\equiv 1\pmod p$</p>
<p>&emsp;&emsp;这个的证明就比较简单了，从剩余系分析即可。而这其实是费马小定理的一种特例。</p>
<h1 id="Miller-Rabin素数测试"><a href="#Miller-Rabin素数测试" class="headerlink" title="Miller_Rabin素数测试"></a>Miller_Rabin素数测试</h1><p>&emsp;&emsp;用费马小定理可以有多种素数的测试方法，Miller-Rabin就是其中一种：</p>
<p>&emsp;&emsp;其算法步骤如下(设$N$为询问素数)：</p>
<p>&emsp;&emsp;&emsp;1、计算奇数$M$，使得$N=2^r\times M+1$</p>
<p>&emsp;&emsp;&emsp;2、选择随机数$A&lt;N$</p>
<p>&emsp;&emsp;&emsp;3、对于任意$i&lt;r$，若$A^{2^i\times M} mod N=N-1$，则$N$通过了随机数$A$的测试</p>
<p>&emsp;&emsp;&emsp;&emsp;&ensp;或者$A^Mmod N=1$,则$N$通过了随机数$A$的测试</p>
<p>&emsp;&emsp;经过$t$次，$N$不是素数的概率为$\frac{1}{4^t}$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h</span><br><span class="line">using namespace std;</span><br><span class="line">const int cnt=10;</span><br><span class="line"></span><br><span class="line">int qpow(int a,int b,int mod)</span><br><span class="line">&#123;</span><br><span class="line">	int res=1;</span><br><span class="line">	for(;b;b=1,a=a*a%mod)</span><br><span class="line">		if(b&amp;1)res=res*a%mod;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Miller_Rabin(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==2)return 1;</span><br><span class="line">	for(int i=0;i&lt;cnt;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int a=rand()%(n-2)+2;</span><br><span class="line">		if(qpow(a,n,n)!=a)return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	if(Miller_Rabin(n))printf(&quot;Probably a prime\n&quot;);</span><br><span class="line">	else printf(&quot;A composite\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这里还有第二种写法，不过需要一个推导，也是基于费马小定理<br>二次探测定理：</p>
<script type="math/tex; mode=display">
对于质数p,方程x^2\equiv1\pmod p，有且只有两个根x\equiv \pm1\pmod p</script><p>&emsp;&emsp;所以我们考虑其逆定理，对于有非$x=1或p-1$的解的模数一定非负。</p>
<p>&emsp;&emsp;因此在用这种方法判断素数是，我们先求出$a^m$，再不断对这个数进行自乘，我们设$x=a^m mod n,y=a^2 mod n$，如果$y=1且x!=1或n-1$显然$p$为合数，可以排除。最后乘完后判断$y$是否为$1$即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool Millar_Rabin(ll n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==2)return 1;</span><br><span class="line">	if(n&lt;2||!(n&amp;1))return 0;</span><br><span class="line">	</span><br><span class="line">	ll m=n-1,k=0;</span><br><span class="line">	while((m&amp;1)==0)&#123;k++;m=1;&#125;</span><br><span class="line">	for(ll i=0;i&lt;times;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll a=rand()%(n-1)+1;</span><br><span class="line">		ll x=qpow(a,m,n),y=0;</span><br><span class="line">		for(ll j=0;j&lt;k;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			y=multi(x,x,n);</span><br><span class="line">			if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1)return 0; </span><br><span class="line">			x=y;</span><br><span class="line">		&#125;</span><br><span class="line">		if(y!=1)return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><p>&emsp;&emsp;费马定理用来求解在素数模下，指数的同余性质，当模数为合数时，就需要用到欧拉定理。</p>
<p>&emsp;&emsp;欧拉函数$\varphi$：对于正整数$n$，欧拉函数是小于等于$n$中与$n$互质的数的个数。</p>
<p>引理1：</p>
<p>&emsp;&emsp;$①$如果$n$为某一个质数$p$，则：$\varphi(p)=p-1$</p>
<p>&emsp;&emsp;$②$如果$n$为某一个质数的幂次$p^a$,则：$\varphi(p^a)=(p-1)\times p^{a-1}$</p>
<p>&emsp;&emsp;$③$如果$n$为任意两个互质的数$a、b$的积，则：$\varphi(a\times b)=\varphi(a)\times \varphi(b)$</p>
<p>证明：</p>
<p>&emsp;&emsp;$①$显然；</p>
<p>&emsp;&emsp;$②$因为比$p^a$小的数有$p^a-1$个。其中，被$p$整除的有$p^{a-1}-1$,所以$\varphi(p^a)=p^a-1-(p^{a-1}-1)=(p-1)\times p^{a-1}$</p>
<p>&emsp;&emsp;$③$对于小于$a\times b$的数共有$a\times b-1$个，其中，只有既与$a$互质，又与$b$互质的数才会和$a\times b$互质，显然满足条件的个数为$\varphi(a)\times \varphi(b)$</p>
<p>引理2：</p>
<p>&emsp;&emsp;设$n=p_1^{r_1}\times p_2^{r_2}\times ···\times p_n^{r_n}$为正整数$n$的素数幂乘积表达式，则</p>
<script type="math/tex; mode=display">
\varphi(n)=n\times (1-\frac{1}{p_1})\times (1-\frac{1}{p_2})\times ···\times (1-\frac{1}{p_n})</script><p>证明：<br>&emsp;&emsp;由于素数幂之间显然互质，由引理$1②③$可知：</p>
<p>&emsp;&emsp;$\varphi(n)=\varphi(p_1^{r_1})\times \varphi(p_2^{r_2})\times ···\times \varphi(p_n^{r_n})$</p>
<p>&emsp;&emsp;&emsp;&emsp;&ensp;$=p_1^{r_1}\times p_2^{r_2}\times ···\times p_n^{r_n}\times (1-\frac{1}{p_1})\times (1-\frac{1}{p_2})\times ···\times (1-\frac{1}{p_n})$</p>
<p>&emsp;&emsp;&emsp;&emsp;&ensp;$=n\times (1-\frac{1}{p_1})\times (1-\frac{1}{p_2})\times ···\times (1-\frac{1}{p_n})$</p>
<p>&emsp;&emsp;欧拉定理：若$a$与$m$互质，则$a^{\varphi(m)}\equiv1(mod m)$</p>
<h1 id="Pollard-Rho-算法求大数因子"><a href="#Pollard-Rho-算法求大数因子" class="headerlink" title="Pollard Rho 算法求大数因子"></a>Pollard Rho 算法求大数因子</h1><p>&emsp;&emsp;在讲$Pollard Rho$之前我们先提一下另一个大整数算法$Fermat$，其算法的实现是先将一个数$M$把而的因数都提取出来，使$M=N\times 2^k$，那么显然$N$是一个奇数，对于一个奇数，如果它是质数，我们就无须分解；如果是合数，我们必定可以转化为$N=c\times d$的形式，我们假设$a=\frac{c+d}{2}$,$b=\frac{c-d}{2}(cd)$,那么显然$N=a^2-b^2$。由于不等式$a^2+b^2\ge 2ab$,我们可知$a=\frac{c+d}{2}\ge \sqrt{c\times d}$，所以我们可以枚举大于$N$的完全平方数$a^2$,判断$a^2-N$是否为完全平方数即可。一组$a、b$就能就出一组$c、d$因子。</p>
<p>&emsp;&emsp;因此我们考虑一种更加有效的方法。$Pollard Rho$算法实质上是生成了两个随机数$a、b$，对于待分解的大整数$N$，我们不断计算$p=gcd(|a-b|,N)$，如果$p$不为$1$就又得到了一个因子，否则我们依赖前一个$a、b$计算，判断$a、b$是否形成循环，形成的话就退出。这样我们必定可以得到一个因子或得到$N$为质数，所以可以继续递归分解。</p>
<p>&emsp;&emsp;但有一点比较麻烦，一般情况下通常使用$b=(a^2+c)mod n$生成随机数据，但是这样判环会比较复杂，我们考虑一种更简便的方法，有一个$Floyd$发明的简便的算法，就是考虑如何使我们知道自己已经走完一圈了，我们只需要令$B$的速度是$A$的两倍，它们同时同向出发后，再次相遇时就走了一圈。</p>
<p>&emsp;&emsp;实际在实现时，我们发现如果$x_i=x_0$时退出，但这样太慢了，我们考虑直接对于一段$x_i$求$gcd$，我们直接把$s=s\times |y-x|$，对于这一段的$s$求$gcd$，而这个段的长度我们可以考虑倍增。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll times=10;</span><br><span class="line">const ll N=5500;</span><br><span class="line"></span><br><span class="line">ll read()</span><br><span class="line">&#123;</span><br><span class="line">	ll res=0,w=1;</span><br><span class="line">	char ch=getchar();</span><br><span class="line">	while(!isdigit(ch))&#123;if(ch==&apos;-&apos;)w=-1;ch=getchar();&#125;</span><br><span class="line">	while(isdigit(ch))res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch^48),ch=getchar();</span><br><span class="line">	return res\times w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">	return !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">ll qpow(ll a,ll b,ll mod)</span><br><span class="line">&#123;</span><br><span class="line">	ll res=1;</span><br><span class="line">	for(;b;b=1,a=a*a%mod)</span><br><span class="line">		if(b&amp;1)res=res*a%mod;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll multi(ll a,ll b,ll mod)</span><br><span class="line">&#123;</span><br><span class="line">	ll res=0;</span><br><span class="line">	for(;b;b=1,a=(a&lt;&lt;1)%mod)</span><br><span class="line">		if(b&amp;1)res=(res+a)%mod;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fac[N],r[N],cnt;</span><br><span class="line">bool Millar_Rabin(ll n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==2)return 1;</span><br><span class="line">	if(n&lt;2||!(n&amp;1))return 0;</span><br><span class="line">	</span><br><span class="line">	ll m=n-1,k=0;</span><br><span class="line">	while((m&amp;1)==0)&#123;k++;m=1;&#125;</span><br><span class="line">	for(ll i=0;i&lt;times;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll a=rand()%(n-1)+1;</span><br><span class="line">		ll x=qpow(a,m,n),y=0;</span><br><span class="line">		for(ll j=0;j&lt;k;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			y=multi(x,x,n);</span><br><span class="line">			if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1)return 0;</span><br><span class="line">			x=y;</span><br><span class="line">		&#125;</span><br><span class="line">		if(y!=1)return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll pollard_rho(ll n,ll c)</span><br><span class="line">&#123;</span><br><span class="line">	ll i=1,k=2,s=1;</span><br><span class="line">	ll x=rand()%(n-1)+1,y=x;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		x=(multi(x,x,n)+c)%n;</span><br><span class="line">		s=multi(s,abs(y-x),n);</span><br><span class="line">		if(y==x||!s)return n;</span><br><span class="line">		if(i==k)</span><br><span class="line">		&#123;</span><br><span class="line">			ll g=gcd(s,n);</span><br><span class="line">			if(g1&amp;&amp;g&lt;n)return g;</span><br><span class="line">			y=x;k&lt;&lt;=1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void find(ll n,ll c)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==1)return ;</span><br><span class="line">	if(Millar_Rabin(n))&#123;fac[++cnt]=n;return ;&#125;</span><br><span class="line">	ll p=n,k=c;</span><br><span class="line">	while(p=n)p=pollard_rho(p,c--);</span><br><span class="line">	find(p,k);</span><br><span class="line">	find(n/p,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	while(~scanf(&quot;%lld&quot;,&amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=0;</span><br><span class="line">		find(n,120);</span><br><span class="line">		sort(fac+1,fac+cnt+1);</span><br><span class="line">		r[1]=1;</span><br><span class="line">		ll k=2;</span><br><span class="line">		for(ll i=2;i&lt;=cnt;i++)</span><br><span class="line">			if(fac[i]==fac[i-1])r[k-1]++;</span><br><span class="line">			else r[k]=1,fac[k++]=fac[i];</span><br><span class="line">		for(ll i=1;i&lt;k;i++)</span><br><span class="line">			printf(&quot;%lld %lld\n&quot;,fac[i],r[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h1><p>&emsp;&emsp;这是一道$NOIP$的初赛题</p>
<p>&emsp;&emsp;阅读下列程序，写出程序结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll g(ll x)</span><br><span class="line">&#123;</span><br><span class="line">	if(x&lt;=1)return x;</span><br><span class="line">	return (2002*g(x-1)+2003*g(x-2))%2005;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">	printf(&quot;%lld&quot;,g(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们分析一下题，实际就是给出递推式求解，我们必须推出通项公式。</p>
<p>&emsp;&emsp;因为:$g(0)=0,g(1)=1$</p>
<p>&emsp;&emsp;所以：$g(n)=[2002\times g(n-1)+2003\times g(n-2)]mod 2005$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$=[-3\times g(n-1)-2\times g(n-2)]mod 2005$</p>
<p>&emsp;&emsp;因此:$g(n)+g(n-1)=[-2\times (g(n-1)+g(n-2))]mod 2005$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$\equiv[(-2)^2\times (g(n-2)+g(n-3))]mod 2005$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$······$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$\equiv[(-2)^{n-1}\times (g(0)+g(1))]mod 2005$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;$\equiv(-2)^{n-1}mod 2005$</p>
<p>&emsp;&emsp;又因为：</p>
<p>&emsp;&emsp;$g(n)+2\times g(n-1)=[-1\times (g(n-1)+2\times g(n-2))]mod 2005$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\equiv[(-1)^2\times (g(n-2)+2\times g(n-3))]mod 2005$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$······$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\equiv[(-1)^{n-1}\times (g(1)+2\times g(0))]mod 2005$</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$(-1)^{n-1}mod 2005$</p>
<p>&emsp;&emsp;由上面两式可得：</p>
<script type="math/tex; mode=display">
g(n)=[(-1)^n-(-2)^n]mod\ 2005</script><p>&emsp;&emsp;所以我们只需要类似快速幂的做法把指数分解做即可。</p>
<h1 id="例2-Visible-Lattice-Points"><a href="#例2-Visible-Lattice-Points" class="headerlink" title="例2 Visible Lattice Points"></a>例2 Visible Lattice Points</h1><p>&emsp;&emsp;从原点看第一象限的点，给出$n$的范围，求范围内能看到的点的个数</p>
<p>&emsp;&emsp;首先我们考虑看到的点一定是对称的，所以我们只要求出下三角或上三角的点数即可。</p>
<p>&emsp;&emsp;而我们考虑每次遍历$x=n$这条直线，会加入$\varphi(n)$个点，所以我们要求的就是$\sum_{i=1}^{n}\varphi(i)$</p>
<p>&emsp;&emsp;我们用欧拉函数的线性筛法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int phi[1005],prime[1005],cnt;</span><br><span class="line">bool v[1005];</span><br><span class="line">void pre(int N)</span><br><span class="line">&#123;</span><br><span class="line">	phi[1]=1;</span><br><span class="line">	for(int i=2;i&lt;=N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!v[i])prime[++cnt]=i,phi[i]=i-1;</span><br><span class="line">		for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			v[i*prime[j]]=1;</span><br><span class="line">			if(!(i%prime[j]))&#123;phi[i*prime[j]]=phi[i]*prime[j];break ;&#125;</span><br><span class="line">			else phi[i*prime[j]]=phi[i]*(prime[j]-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pre(1000);</span><br><span class="line">	int t,cas=0;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		int n,ans=0;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">			ans+=phi[i];</span><br><span class="line">		printf(&quot;%d %d %d\n&quot;,++cas,n,ans*2+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">fbz</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://fangbozhen.github.io/2019/11/05/%E7%B4%A0%E6%95%B0/">https://fangbozhen.github.io/2019/11/05/%E7%B4%A0%E6%95%B0/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://fangbozhen.github.io">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fangbozhen.github.io">fbz</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/11/05/Catalan%E6%95%B0/"><span>Catalen数</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2019 By fbz</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/mathjax/mathjax.js"></script><!--script(src=url)--></body></html>